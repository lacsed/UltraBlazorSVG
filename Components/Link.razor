@{
CultureInfo.CurrentCulture = CultureInfo.InvariantCulture;
if(isCurved)
{
    <path d="M @arcStart.x @arcStart.y A @arcRadius @arcRadius 0 @largeArcFlag @sweepFlag @arcEnd.x @arcEnd.y" fill="none" style="outline: none;" stroke="black" tabindex="0" stroke-width="2" />
    <path d="M @arcStart.x @arcStart.y A @arcRadius @arcRadius 0 @largeArcFlag @sweepFlag @arcEnd.x @arcEnd.y" fill="none" style="outline: none;" stroke="transparent" tabindex="0" stroke-width="10" pointer-events="stroke" />
} 
else
{
    <line x1="@lineStart.x" y1="@lineStart.y" x2="@arrowTip.x" y2="@arrowTip.y" tabindex="0" stroke="transparent" style="outline: none;" stroke-width="10" pointer-events="stroke" 
            @onfocusin="HandleFocusIn"/>
    <line x1="@lineStart.x" y1="@lineStart.y" x2="@lineEnd.x" y2="@lineEnd.y" stroke="@linkColor" stroke-width="2" />
}
<polygon points="@arrowTip.x @arrowTip.y @rightWing.x @rightWing.y @leftWing.x @leftWing.y" tabindex="0" fill="@linkColor" style="outline: none;" stroke-width="1" />
}


@code {
    [Parameter]
    public Vector2D? originState { get; set; }
    [Parameter]
    public Vector2D? destinationState { get; set; }
    [Parameter]
    public Vector2D? svgOrigin { get; set; }

    [Parameter]
    public EventCallback<Link> onLinkSelected { get; set; }
    [Parameter]
    public EventCallback<Link> onLinkDeSelected { get; set; }

    private Vector2D lineStart = new Vector2D();
    private Vector2D lineEnd = new Vector2D();

    private Vector2D arcStart = new Vector2D();
    private Vector2D arcEnd = new Vector2D();

    private Vector2D arrowTip = new Vector2D();
    private Vector2D rightWing = new Vector2D();
    private Vector2D leftWing = new Vector2D();

    private Vector2D arcCenter = new Vector2D();

    private bool isCurved = false;

    private float centerRatio = 0.4f;
    private float arcRadius = 10;
    private float arrowLength = 10;
    private float arrowWidth = 10;
    private float nodeRadius = 50;

    private int largeArcFlag = 0;
    private int sweepFlag = 0;

    private string linkColor = "blue";

    protected override async Task OnParametersSetAsync()
    {
        Vector2D transitionDirection = (destinationState - originState).Normalized();
        Vector2D midPos = originState.Middle(destinationState);
        Vector2D perpendicularDirection = transitionDirection.Perpendicular();

        float transDist = (destinationState - originState).Length();

        if (isCurved)
        {
            Vector2D center = midPos + perpendicularDirection * centerRatio * transDist;

            arcRadius = (originState - center).Length();
            float rtDir = (sweepFlag == 1) ? -1 : 1;

            Vector2D vCenterOrigin = originState - center;
            Vector2D vCenterDestination = destinationState - center;

            float ndRadAng = Vector2D.AngleBetween(nodeRadius, arcRadius, arcRadius);
            float arwAng = Vector2D.AngleBetween(arrowLength, arcRadius, arcRadius);

            Vector2D vCenterArcStart = vCenterOrigin.Rotated(rtDir * ndRadAng);
            Vector2D vCenterArrowTip = vCenterDestination.Rotated(-rtDir * ndRadAng);
            Vector2D vCenterArcEnd = vCenterArrowTip.Rotated(-rtDir * arwAng);

            Vector2D tArcStart = center + vCenterArcStart;
            Vector2D tArcEnd = center + vCenterArcEnd;
            Vector2D tArrowTip = center + vCenterArrowTip;

            Vector2D arrowDirection = (tArrowTip - tArcEnd).Normalized();
            Vector2D arrowPerpendicular = arrowDirection.Perpendicular();

            Vector2D tArrowRightWing = tArcEnd + arrowPerpendicular * arrowWidth / 2;
            Vector2D tArrowLeftWing = tArcEnd - arrowPerpendicular * arrowWidth / 2;

            arcStart = tArcStart.ToSvgCoordinates(svgOrigin);
            arcEnd = tArcEnd.ToSvgCoordinates(svgOrigin);

            arrowTip = tArrowTip.ToSvgCoordinates(svgOrigin);
            rightWing = tArrowRightWing.ToSvgCoordinates(svgOrigin);
            leftWing = tArrowLeftWing.ToSvgCoordinates(svgOrigin);
        }
        else
        {
            lineStart = originState + transitionDirection * nodeRadius;
            lineEnd = destinationState - transitionDirection * (nodeRadius + arrowLength);

            arrowTip = destinationState - transitionDirection * nodeRadius;
            rightWing = lineEnd + perpendicularDirection * arrowWidth / 2;
            leftWing = lineEnd - perpendicularDirection * arrowWidth / 2;

            lineStart = lineStart.ToSvgCoordinates(svgOrigin);
            lineEnd = lineEnd.ToSvgCoordinates(svgOrigin);

            arrowTip = arrowTip.ToSvgCoordinates(svgOrigin);
            rightWing = rightWing.ToSvgCoordinates(svgOrigin);
            leftWing = leftWing.ToSvgCoordinates(svgOrigin);
        }

        await InvokeAsync(StateHasChanged);
    }

    private async Task HandleFocusIn()
    {
        linkColor = "blue";
        await onLinkSelected.InvokeAsync(this);
        await InvokeAsync(StateHasChanged);
    }

    private async Task HandleFocusOut()
    {
        Console.WriteLine("perdeu foco");
        linkColor = "black";
        await onLinkDeSelected.InvokeAsync(this);
        await InvokeAsync(StateHasChanged);
    }

    public async Task HandleMouseMove(MouseEventArgs e)
    {
        Console.WriteLine("mouse movendo");
        float tolerance = 0.1f;
        float margin = 0.08f;

        Vector2D msPosSVG = new Vector2D((float)e.OffsetX, (float)e.OffsetY);
        Vector2D mousePosition = new Vector2D((float)e.OffsetX, (float)e.OffsetY).FromSvgCoordinates(svgOrigin);

        Vector2D midPos = originState.Middle(destinationState);

        Vector2D vOD = destinationState - originState;
        Vector2D vOM = mousePosition - originState;
        Vector2D vDM = mousePosition - destinationState;

        float distT = vOD.Length();
        float distOM = vOM.Length();
        float distDM = vDM.Length();
        float distMM = (midPos - mousePosition).Length();
        float transRad = distT / 2;

        float distMT = Vector2D.DistanceToLine(mousePosition, originState, destinationState);

        sweepFlag = (vOD.Cross(vOM) > 0) ? 1 : 0;

        isCurved = true;

        if (distMT < tolerance * distT)
        {
            isCurved = false;
        }
        else if (Math.Abs(distMM - transRad) < margin * transRad)
        {
            centerRatio = 0;
            largeArcFlag = 0;
        }
        else
        {
            Vector2D center = Vector2D.FindCenter(originState, mousePosition, destinationState);

            float radius = (destinationState - center).Length();
            float distCM = (midPos - center).Length();

            Vector2D vOC = (center - originState);
            float value = vOD.Cross(vOC);

            centerRatio = (vOD.Cross(vOC) > 0) ? -distCM / distT : distCM / distT;
            largeArcFlag = (distMM < distT / 2) ? 0 : 1;
        }

        await InvokeAsync(StateHasChanged);
    }

    private float FindRadius(Vector2D center, Vector2D point)
    {
        return (center - point).Length();
    }
}
