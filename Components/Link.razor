@{
CultureInfo.CurrentCulture = CultureInfo.InvariantCulture;
if(isCurved)
{
    <path d="M @arcStart.x @arcStart.y A @arcRadius @arcRadius 0 @largeArcFlag @sweepFlag @arcEnd.x @arcEnd.y" fill="none" style="outline: none;" stroke="black" tabindex="0" stroke-width="2" />
    <path d="M @arcStart.x @arcStart.y A @arcRadius @arcRadius 0 @largeArcFlag @sweepFlag @arcEnd.x @arcEnd.y" fill="none" style="outline: none;" stroke="transparent" tabindex="0" stroke-width="10" pointer-events="stroke" />
} 
else
{
    <line x1="@lineStart.x" y1="@lineStart.y" x2="@arrowTip.x" y2="@arrowTip.y" tabindex="0" stroke="red" style="outline: none;" stroke-width="10" pointer-events="stroke" 
            @onfocusin="HandleFocusIn" @onfocusout="HandleFocusOut"/>
    <line x1="@lineStart.x" y1="@lineStart.y" x2="@lineEnd.x" y2="@lineEnd.y" stroke="@linkColor" stroke-width="2" />
}
<polygon points="@arrowTip.x @arrowTip.y @rightWing.x @rightWing.y @leftWing.x @leftWing.y" tabindex="0" fill="@linkColor" style="outline: none;" stroke-width="1" />
}


@code {
    [Parameter]
    public Vector2D? originState { get; set; }
    [Parameter]
    public Vector2D? destinationState { get; set; }
    [Parameter]
    public Vector2D? svgOrigin { get; set; }

    [Parameter]
    public EventCallback<Link> onLinkSelected { get; set; }
    [Parameter]
    public EventCallback<Link> onLinkDeSelected { get; set; }

    private Vector2D lineStart = new Vector2D();
    private Vector2D lineEnd = new Vector2D();

    private Vector2D arcStart = new Vector2D();
    private Vector2D arcEnd = new Vector2D();

    private Vector2D arrowTip = new Vector2D();
    private Vector2D rightWing = new Vector2D();
    private Vector2D leftWing = new Vector2D();

    private bool isCurved = false;

    private float arcPercentage = 0.4f;
    private float arcRadius = 10;
    private float arrowLength = 10;
    private float arrowWidth = 10;
    private float nodeRadius = 50;

    private int largeArcFlag = 0;
    private int sweepFlag = 0;

    private string linkColor = "blue";

    protected override async Task OnParametersSetAsync()
    {
        Vector2D transitionDirection = (destinationState - originState).Normalized();
        Vector2D perpendicularDirection = transitionDirection.Perpendicular();

        if (isCurved)
        {
            float nodeArcAngle = Vector2D.AngleBetween(nodeRadius, arcRadius, arcRadius);
            float arrowArcAngle = Vector2D.AngleBetween(arrowLength, arcRadius, arcRadius);

            if (arcPercentage > 0)
            {
                float centerOffset = (1 - arcPercentage);

                Vector2D arcCenter = originState.Middle(destinationState) - perpendicularDirection * centerOffset * arcRadius;

                Vector2D centerToOrigin = originState - arcCenter;
                Vector2D centerToDestination = destinationState - arcCenter;

                arcStart = arcCenter + centerToOrigin.Rotated(nodeArcAngle);
                arcEnd = arcCenter + centerToDestination.Rotated(-(nodeArcAngle + arrowArcAngle));

                arrowTip = arcCenter + centerToDestination.Rotated(-nodeArcAngle);
            }
            else
            {
                float centerOffset = -(1 + arcPercentage);

                Vector2D arcCenter = originState.Middle(destinationState) - perpendicularDirection * centerOffset * arcRadius;

                Vector2D centerToOrigin = originState - arcCenter;
                Vector2D centerToDestination = destinationState - arcCenter;

                arcStart = arcCenter + centerToOrigin.Rotated(-nodeArcAngle);
                arcEnd = arcCenter + centerToDestination.Rotated(nodeArcAngle + arrowArcAngle);

                arrowTip = arcCenter + centerToDestination.Rotated(nodeArcAngle);
            }

            Vector2D arrowDirection = (arrowTip - arcEnd).Normalized();
            Vector2D arrowPerpendicular = arrowDirection.Perpendicular();

            rightWing = arcEnd + arrowPerpendicular * arrowWidth / 2;
            leftWing = arcEnd - arrowPerpendicular * arrowWidth / 2;

            arcStart = arcStart.ToSvgCoordinates(svgOrigin);
            arcEnd = arcEnd.ToSvgCoordinates(svgOrigin);

            arrowTip = arrowTip.ToSvgCoordinates(svgOrigin);
            rightWing = rightWing.ToSvgCoordinates(svgOrigin);
            leftWing = leftWing.ToSvgCoordinates(svgOrigin);
        }
        else
        {
            lineStart = originState + transitionDirection * nodeRadius;
            lineEnd = destinationState - transitionDirection * (nodeRadius + arrowLength);

            arrowTip = destinationState - transitionDirection * nodeRadius;
            rightWing = lineEnd + perpendicularDirection * arrowWidth / 2;
            leftWing = lineEnd - perpendicularDirection * arrowWidth / 2;

            lineStart = lineStart.ToSvgCoordinates(svgOrigin);
            lineEnd = lineEnd.ToSvgCoordinates(svgOrigin);

            arrowTip = arrowTip.ToSvgCoordinates(svgOrigin);
            rightWing = rightWing.ToSvgCoordinates(svgOrigin);
            leftWing = leftWing.ToSvgCoordinates(svgOrigin);
        }

        await InvokeAsync(StateHasChanged);
    }

    private async Task HandleFocusIn()
    {
        linkColor = "blue";
        await onLinkSelected.InvokeAsync(this);
        await InvokeAsync(StateHasChanged);
    }

    private async Task HandleFocusOut()
    {
        linkColor = "black";
        await onLinkDeSelected.InvokeAsync(this);
        await InvokeAsync(StateHasChanged);
    }

    public async Task HandleMouseMove(MouseEventArgs e)
    {
        Vector2D mousePosition = new Vector2D((float)e.OffsetX, (float)e.OffsetY).FromSvgCoordinates(svgOrigin);
        Vector2D middlePoint = originState.Middle(destinationState);

        float transitionDistance = (destinationState - originState).Length();

        Vector2D mouseToOrigin = originState - mousePosition;
        Vector2D mouseToDestination = destinationState - mousePosition;
        Vector2D mouseToMiddle = middlePoint - mousePosition;
        Vector2D originToDestination = destinationState - originState;

        float distanceMouseToTransition = mouseToMiddle.Length() * (float)Math.Sin(mouseToMiddle.AngleBetween(originToDestination));

        float angleX = mouseToOrigin.AngleBetween(originToDestination);
        float angleY = (float)Math.PI - mouseToOrigin.AngleBetween(mouseToDestination);
        float angleZ = mouseToDestination.AngleBetween(originToDestination);

        float angleAlpha = (angleY - angleZ - angleX) / 2;

        arcRadius = transitionDistance / (2 * (float)Math.Cos(angleAlpha));

        float height = (float)Math.Sqrt(Math.Pow(arcRadius, 2) - Math.Pow(transitionDistance, 2));

        float distanceMouseMiddle = (middlePoint - mousePosition).Length();

        isCurved = true;

        if (distanceMouseMiddle > transitionDistance / 2)
        {
            arcPercentage = 1;
        }
        else if (distanceMouseToTransition <= 0.01 * transitionDistance)
        {
            isCurved = false;
        }
        else
        {
            arcPercentage = (arcRadius - height) / arcRadius;
        }

        Vector2D middleToMouse = mousePosition - middlePoint;
        Vector2D middleToOrigin = mousePosition - middlePoint;

        float crossValue = middleToOrigin.Cross(middleToMouse);

        if (crossValue > 0)
        {
            sweepFlag = 1;
        } else if (crossValue < 0)
        {
            sweepFlag = 0;
        }

        largeArcFlag = 0;

        await InvokeAsync(StateHasChanged);
    }

    private Vector2D FindCenter(Vector2D A, Vector2D B, Vector2D C)
    {
        float slopeAB;
        float slopeBC;

        if (Math.Abs(B.x - A.x) < float.Epsilon)
        {
            slopeAB = float.PositiveInfinity;
        }
        else
        {
            slopeAB = (B.y - A.y) / (B.x - A.x);
        }

        if (Math.Abs(C.x - B.x) < float.Epsilon)
        {
            slopeBC = float.PositiveInfinity;
        }
        else
        {
            slopeBC = (C.y - B.y) / (C.x - B.x);
        }

        // Check if the points are collinear
        if (Math.Abs(slopeAB - slopeBC) < float.Epsilon)
        {
            throw new Exception("Points are collinear, no unique circle exists.");
        }

        Vector2D midpointAB = new Vector2D((A.x + B.x) / 2, (A.y + B.y) / 2);
        Vector2D midpointBC = new Vector2D((B.x + C.x) / 2, (B.y + C.y) / 2);

        bool centerAbove = midpointAB.y < A.y;

        float perpendicularAB = -1 / slopeAB;
        float perpendicularBC = -1 / slopeBC;

        float interceptAB = midpointAB.y - perpendicularAB * midpointAB.x;
        float interceptBC = midpointBC.y - perpendicularBC * midpointBC.x;

        float center_x;
        float center_y;

        if (float.IsInfinity(perpendicularAB))
        {
            center_x = midpointAB.x;
            center_y = centerAbove ? perpendicularBC * center_x + interceptBC : -perpendicularBC * center_x - interceptBC;
        }
        else if (float.IsInfinity(perpendicularBC))
        {
            center_x = midpointBC.x;
            center_y = centerAbove ? perpendicularAB * center_x + interceptAB : -perpendicularAB * center_x - interceptAB;
        }
        else
        {
            center_x = (interceptBC - interceptAB) / (perpendicularAB - perpendicularBC);
            center_y = centerAbove ? perpendicularAB * center_x + interceptAB : -perpendicularAB * center_x - interceptAB;
        }
        Console.WriteLine("olha o centro = " + new Vector2D(center_x, center_y));
        return new Vector2D(center_x, center_y);
    }

    private float FindRadius(Vector2D center, Vector2D point)
    {
        return (center - point).Length();
    }
}
